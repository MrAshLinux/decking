{"name":"Decking","tagline":"A Docker helper to create, manage and run clusters of containers","body":"# deckingâ€”simplified management for clusters of Docker containers\r\n\r\nDecking aims to simplify the creation, management and running of clusters\r\nof Docker containers in a way which is familiar to developers;\r\nby reading information from a `decking.json` package file\r\non a project by project basis.\r\n\r\nIt simplifies the building of images based on local Dockerfiles which can ordinarily be a time-consuming and error prone process (building the wrong Dockerfile as the wrong image, and having to move the Dockerfile to the root of a project in order to make the `ADD` directive work properly).\r\n\r\nIt simplifies the creation of containers by considering `docker run` parameters to be part of the definition of each\r\ncontainer - again meaning less room for error as each developer doesn't have to remember the correct run time parameters to use when creating each container.\r\n\r\nIt simplifies the running of containers by allowing dependencies to be specified, ensuring that all containers forming\r\npart of a cluster are started in the correct order such that `-link` parameters work as expected. Entire clusters of containers can be started, stopped or attached to with a single command, without having to worry about restarting them in dependency order.\r\n\r\nIt intends to use the Docker Remote API wherever possible (not everywhere, does\r\nnot appear to support `-name` and `-link` flags yet).\r\n\r\nPlease view [this showterm recording](http://showterm.io/21bc0f5d5ddbe4a1c4f2a) of decking in action as used by [makeusabrew/nodeflakes](https://github.com/makeusabrew/nodeflakes) (check out its [decking.json](https://github.com/makeusabrew/nodeflakes/blob/master/decking.json) definition for full details).\r\n\r\n## Installation\r\n\r\nBe warned: decking is *very* rough around the edges at the moment. If you want to get stuck in\r\nthen just clone the repository and run `./bin/decking` - it'll display the most up-to-date\r\nlist of commands (which might not be the same as those listed below). You'll need CoffeeScript\r\nto run the executable. Alternatively, you can install the latest version published on npm:\r\n\r\n```sudo npm install -g decking```\r\n\r\nNote that the 0.0.x releases on npm are likely to be pretty unstable!\r\n\r\n## Methods\r\n\r\n**build (image | all)** - alleviate the inconvenience of ADD requiring a local (./ downwards)\r\ncontext and ensure error-free mapping of Dockerfiles to image names.\r\n\r\n**create (cluster)** - create a cluster of containers based on parameters found in the decking.json file. Dependencies can be specified which will ensure containers used as `-link` parameters exist before creation of their dependents.\r\n\r\n**start (cluster)** - start a cluster (must call `create` first - for now). Dependencies are started first so `-link`s work properly\r\n\r\n**stop (cluster)** - stop a cluster\r\n\r\n**restart (cluster)** - restart a cluster\r\n\r\n**status (cluster)** - show the status of each container in a cluster (started / stopped / non-existent)\r\n\r\n**attach (cluster)** - multiplex the output from all running containers in a cluster into one stdout / stderr stream. Automatically re-attaches if a container stops but comes back within 10 seconds.\r\n\r\nIf you only have one cluster definition in your decking.json file (see below) then `<cluster>` may be omitted, meaning in practice you can usually simply type `decking start`, `decking stop` etc.\r\n\r\n## decking.json format\r\n\r\n### images (Object)\r\n\r\nEach key is the name of the image you want to build. Each value is the location of\r\nthe *local* Dockerfile relative to the project root. That's right; only local images\r\ncan be built at the moment, although eventually you'll be able to specify tag names\r\nto build an image from the Docker Index instead.\r\n\r\n```\r\n\"images\": {\r\n  \"makeusabrew/nodeflakes\": \"./docker/base\",\r\n  \"makeusabrew/nodeflakes-server\": \"./docker/server\",\r\n  \"makeusabrew/nodeflakes-consumer\": \"./docker/consumer\",\r\n  \"makeusabrew/nodeflakes-processor\": \"./docker/processor\"\r\n}\r\n```\r\n\r\nWhen building an image the relevant Dockerfile will be copied to the root of your project (i.e. to the same level as your decking.json file) such that any `ADD` directives will be relative to your project root (which in my experience, or at least how I use Dockerfiles, is always the desired behaviour).\r\n\r\n### containers (Object)\r\n\r\nKeys are the names you want to run your images as (e.g. `docker run -name <key> ...`). Values are either a string - in which case they must refer to a valid `images` key - or an object. A definition of two containers demonstrating both approaches might look a bit like this:\r\n\r\n```\r\n\"containers\": {\r\n  \"nfprocessor\": {\r\n    \"image\": \"makeusabrew/nodeflakes-processor\",  // must exist in images object\r\n    \"port\" : [\"1234:1234\"],\r\n    \"env\": : [\"MY_ENV_VAR=value\", \"ANOTHER_VAR=-\"]\r\n    \"dependencies\": [\r\n      \"nfconsumer:consumer\"\r\n    ],\r\n    \"mount\": [\"/path/to/host-dir:/path/to/container-dir\"]\r\n  },\r\n  \"nfconsumer\": \"makeusabrew/nodeflakes-consumer\"  // shorthand, this container requires no other run args\r\n}\r\n```\r\n\r\nEach key in the definition of `nfprocessor` maps loosely onto an argument which will be passed to `docker run`:\r\n\r\n* port -> `-p`\r\n* env -> `-e`\r\n* dependencies -> `-link`\r\n* mount -> `-v`\r\n* image -> supplied as-is as the last part of the run command\r\n\r\nIt might be simpler to remove this abstraction and just name these keys exactly as per the arguments passed to docker run, but you'd end up with some pretty ugly looking definitions full of single letter keys. Nevertheless, this *may* change.\r\n\r\nNotice that our env var `ANOTHER_VAR` is defined simply as `-`. This is a special value which, when the container is first created, will be substituted with the current value of `process.env['ANOTHER_VAR']`. If that yields a falsy value the user will be prompted for it. **Please note** that you will only be prompted for any missing environment variables *once* when calling `decking create <cluster>`. Of course, if you manually `docker rm` a container used in the cluster and then call `decking create <cluster>` again you will be prompted for the value once more.\r\n\r\n### clusters (Object)\r\n\r\nKeys are the names of clusters you want to refer to, values are just arrays of keys found in the `containers` object. These definitions are simple as most of the configuration has already been done:\r\n\r\n```\r\n\"clusters\": {\r\n  \"main\": [\"nfprocessor\", \"nfconsumer\"]\r\n}\r\n```\r\n\r\nNote that the order we list our containers as part of each cluster definition doesn't matter - decking will resolve the dependencies based on each container's definition and make sure they start in the correct order.\r\n\r\nAs we have only defined one cluster we can omit it when calling any of the main decking commands - e.g. `decking start main` can be shortened to `decking start`. If two or more cluster definitions are present then a cluster name must always be provided.\r\n\r\n### groups (optional Object)\r\n\r\nGroups allow clusters of containers to be run with different parameters. For example:\r\n\r\n```\r\n\"groups\": {\r\n    \"build\": {\r\n        \"options\": {\r\n            \"env\":   [\"NODE_ENV=build\"],\r\n            \"mount\": [\".:/path/to/src\"]\r\n        },\r\n        \"containers\": {\r\n            \"nfprocessor\": {\r\n                \"port\": [\"4321:1234\"]\r\n            }\r\n        }\r\n    }\r\n    \r\n}\r\n```\r\n\r\nThe above would create a new group called `build`, which when used would apply the relevant options\r\nwhen creating a cluster of containers. Per-container overrides can also be set, though these are\r\noptional. Opting into a group simply requires a slightly different cluster definition:\r\n\r\n```\r\n\"clusters\": {\r\n  \"main\": [\"nfprocessor\", \"nfconsumer\"],\r\n  \"dev\": {\r\n      \"group\": \"build\",\r\n      \"containers\": [\"nfprocessor\", \"nfconsumer\"]\r\n  }\r\n}\r\n```\r\n\r\nThis would let us run two clusters based on the same containers, albeit one very clearly in\r\na 'build' mode. Of course we can't have two containers with different configurations sharing\r\nthe same `-name`, so decking namespaces containers based on the group name. In the above example,\r\na call to `decking create dev` would look for containers named `nfprocessor.build` and\r\n`nfconsumer.build`. This namespacing is transparent to a user, meaning containers can always\r\nbe thought of and referred to (i.e. as dependencies) by their original name.\r\n\r\nNote that for now, group-wide options completely overwrite any previous values for matching keys\r\nrather than merge them with existing ones. Likewise, a container-level override overwrites\r\nany previous values (even those set at group level). This will be changed in future such that\r\noptions are merged properly in a predictable manner.\r\n\r\nSee [nodeflakes/decking.json](https://github.com/makeusabrew/nodeflakes/blob/master/decking.json) for a valid - albeit rather simple - decking.json file.\r\n\r\n## TODO\r\n\r\n* proper error checking - so many cases not handled at all, let alone gracefully\r\n* implement optional building of parent images when given a flag\r\n* allow container image to be omitted if other keys are present; fuzzy match on images object\r\n* tests!\r\n* rework all output to always show full container list and update lines as necessary\r\n* provide options to exclude 'implicit' cluster deps on start/stop/create\r\n* add 'destroy' method - with appropriate warnings\r\n* only allow standard 'word' characters in container names\r\n* ensure dependencies have actually started before starting children (i.e. check port / logs)\r\n","google":"UA-20517424-10","note":"Don't delete this file! It's used internally to help with page regeneration."}