<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Create, manage and run clusters of Docker containers | decking.io</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>decking</h1>
        <h2>Create, manage and run clusters of Docker containers</h2>
        <a href="https://github.com/makeusabrew/decking" class="button"><small>View project on </small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <!--<h1> <span class="octicon octicon-link"></span>Simplified management for clusters of Docker containers</h1>-->

<p>Decking aims to simplify the creation, management and running of clusters
of Docker containers in a way which is familiar to developers;
by reading information from a <code>decking.json</code> package file
on a project by project basis. You can view a
<a href="http://showterm.io/21bc0f5d5ddbe4a1c4f2a">showterm recording</a>
of decking in action or check out a simple
<a href="https://github.com/makeusabrew/nodeflakes/blob/master/decking.json">decking.json</a>
example file.</p>

<!--
<iframe src="http://showterm.io/21bc0f5d5ddbe4a1c4f2a#fast" width="100%" height="480"></iframe>
-->

<h2>
<a name="installation" class="anchor"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>Although under heavy development, the more recent releases on npm are stable:</p>

<pre class="reduced">$ [sudo] <b>npm install -g decking</b></pre>

<p>Alternatively, just clone the repo and run <code>./bin/decking</code>. You&rsquo;ll
need CoffeeScript installed globally in order to use the development version.</p>

<p>Once installed decking can be run (without arguments) from anywhere:</p>
<pre class="reduced reduced--alot">$ <b>decking</b>

Usage: decking COMMAND [arg...]

Commands:
  build    build an image or pass 'all' to build all
  create   create a cluster of containers
  start    start a cluster
  stop     stop a cluster
  restart  restart a cluster
  status   check the status of a cluster's containers
  attach   attach to all running containers in a cluster

Version: 0.0.12</pre>

<p>These commands only make sense with some context; that context must be provided
by a local <b>decking.json</b> file.</p>

<h2>
<a name="about" class="anchor"><span class="octicon octicon-link"></span></a>Why decking?</h2>

<!--<p>Possible note here about lack of metadata storage with Docker</p>-->
<p>Whilst <a href="http://www.docker.io/">Docker</a> is fantastic, it lacks
any way of associating valuable metadata with images or containers. A Dockerfile
can&rsquo;t enforce that it be built as a certain image name. More importantly, an
image can&rsquo;t enforce that it be created with certain runtime values when
creating a specific type of container. Docker provides flexible, abstract
building blocks. Decking transforms these building blocks into
concrete implementations of services&mdash;and clusters of services&mdash;in a
robust, repeatable, configuration-driven manner. It allows simple but powerful
dependency modelling and takes all the hassle (and error) out of starting
clusters of containers in the correct dependency order. It allows optional
overrides to fine-tune cluster configuration on a per-environment basis.

<p>It simplifies the <b>building of images</b> based on local Dockerfiles which
can ordinarily be a time-consuming and error prone process (building the wrong
Dockerfile as the wrong image, and having to move the Dockerfile to the root of
a project in order to make the <code>ADD</code> directive work properly).</p>

<p>It simplifies the <b>creation of containers</b> by considering
<code>docker run</code> parameters to be part of the definition of each
container, meaning less room for error as each developer doesn&rsquo;t have
to remember the correct runtime parameters to use when creating each
container.</p>

<p>It simplifies the <b>orchestration of containers</b> by allowing dependencies
to be specified, ensuring that all containers forming part of a cluster are
started in the correct order such that <code>-link</code> parameters work as
expected. Entire clusters of containers can be started, stopped or attached to
with a single command, without having to worry about (re)starting them in
dependency order.</p>

<h2>
<a name="format" class="anchor"><span class="octicon octicon-link"></span></a>The decking.json file format</h2>

<p>The decking.json format aims to be clear, concise and simple. Note that the file
must be present in the current working directory; decking will not recurse up parent
directories looking for a valid definition file. The top-level keys are:</p>

<pre><code>"images":     { /* the images which power your containers */ },
"containers": { /* the container templates which make up your clusters */ },
"clusters":   { /* lists of containers which combine to form a cluster */ },
"groups":     { /* optional overrides for different environments */ }
</code></pre>

<h3>
<a name="format-images" class="anchor"><span class="octicon octicon-link"></span></a>images</h3>

<p>Images define the templates from which containers are built; decking gives them
a boost by being able to build them in batches and resolving commonly experienced issues with
Docker&rsquo;s &lsquo;context&rsquo; restrictions.</p>

<ul class="requirements">
  <li>required: <b>no</b></li>
  <li>type: <b>object</b></li>
</ul>

<p>Each key is the name of the image you want to build. Each value is the location of
the <em>local</em> Dockerfile relative to the project root. Only local images
can be built at the moment, although eventually you&rsquo;ll be able to specify tag names
as values in to build an image from the Docker Index instead.</p>

<pre><code>"images": {
  "makeusabrew/nodeflakes": "./docker/base",
  "makeusabrew/nodeflakes-server": "./docker/server",
  "makeusabrew/nodeflakes-consumer": "./docker/consumer",
  "makeusabrew/nodeflakes-processor": "./docker/processor"
}
</code></pre>

<p>When building an image the relevant Dockerfile will be copied to the root
of your project (i.e. to the same directory as your decking.json file) such
that any <code>ADD</code> directives will be relative to your project root.</p>

<h3>
<a name="format-containers" class="anchor"><span class="octicon octicon-link"></span></a>containers</h3>

<p>Containers define the runtime configuration for a given image. They let you
model instances&mdash;and crucially, their dependencies&mdash;in a clear, clean
and repeatable manner, meaning you don&rsquo;t have to remember all those arguments
when creating a new container.</p>

<ul class="requirements">
  <li>required: <b>yes</b></li>
  <li>type: <b>object</b></li>
</ul>

<p>Keys are the names you want to run your containers as (e.g.
<code>docker run -name &lt;key&gt; ...</code>). Values are either
a string&mdash;in which case they are assumed to refer to an image&mdash;or an
object. A definition of two containers demonstrating
both approaches might look a bit like this:</p>

<pre><code>"containers": {
  "nfprocessor": {
    "image": "makeusabrew/nodeflakes-processor",
    "port" : ["1234:1234"],
    "env": : ["MY_ENV_VAR=value", "ANOTHER_VAR=-"]
    "dependencies": [
      "nfconsumer:consumer"
    ],
    "mount": ["/path/to/host-dir:/path/to/container-dir"]
  },
  "nfconsumer": "makeusabrew/nodeflakes-consumer"
}
</code></pre>

<p>Each key in the definition of <code>nfprocessor</code> maps loosely onto an argument which will be passed to <code>docker run</code>:</p>

<pre class="reduced">port         &rarr; <b>-p</b>
env          &rarr; <b>-e</b>
dependencies &rarr; <b>-link</b>
mount        &rarr; <b>-v</b>
image        &ndash; supplied as-is as the last part of the run command</pre>

<!--<p>It might be simpler to remove this abstraction and just name these keys exactly as per the arguments passed to docker run, but you&rsquo;d end up with some pretty ugly looking definitions full of single letter keys. Nevertheless, this <em>may</em> change.</p>-->

<h4>Dynamic values</h4>

<p>Notice that our env var <code>ANOTHER_VAR</code> is defined simply as
<code>-</code>. This is a special value which will be substituted with the
current value of the host machine&rsquo;s <code>$ANOTHER_VAR</code> environment
variable. If that yields an empty value the user will be prompted for it. You
will only be prompted for any missing environment variables when calling
<code>decking create &lt;cluster&gt;</code>. This is particularly useful
if you don&rsquo;t want to store sensitive information in your configuration
file (such as API keys) or the relevant variable differs per host (such
as a lookup of the host&rsquo;s IP address).</p>

<h3>
<a name="format-clusters" class="anchor"><span class="octicon octicon-link"></span></a>clusters</h3>

<p>Clusters define sets of related containers which&mdash;presumably&mdash;combine
in some useful way (e.g. a master &amp; slave database, a couple of web servers
and a load balancer). This is where it all happens!

<ul class="requirements">
  <li>required: <b>yes</b></li>
  <li>type: <b>object</b></li>
</ul>

<p>Keys are the names of clusters you want to refer to, values are usually
just arrays of names found in the <code>containers</code> object. These
definitions are simple as most of the configuration has already been done
elsewhere:</p>

<pre><code>"clusters": {
  "main": ["nfprocessor", "nfconsumer"]
}
</code></pre>

<p>The order we list our containers as part of each cluster definition
doesn&rsquo;t matter&mdash;decking will resolve the dependencies based on each
container&rsquo;s definition and make sure they start in the correct order.
Similarly, dependencies don&rsquo;t <i>have</i> to be explicitly listed as part
of a cluster; if you want to run containers A and B as a cluster, and B
happens to depend on C, then C will be started too&mdash;even if you aren&rsquo;t
really interested in it when mentally modelling your cluster.</p>

<p>In this example as we have only defined one cluster we can omit it when
calling any of the cluster related commands &ndash; e.g.
<code>decking start main</code> can be shortened to
<code>decking start</code>. If two or more cluster definitions are present
then a cluster name must always be provided as otherwise decking won&rsquo;t
know which one you&rsquo;re refering to.</p>

<h3>
<a name="format-groups" class="anchor"><span class="octicon octicon-link"></span></a>groups</h3>

<p>Groups allow clusters of containers to be run with different parameters, usually
to support small configuration variations across different environments (e.g.
build, test, production) without having to define entirely new containers.</p>

<ul class="requirements">
  <li>required: <b>no</b></li>
  <li>type: <b>object</b></li>
</ul>

<p>Keys are arbitrary names to associate with each group, values are
cluster-wide and container-specific overrides:</p>

<pre><code>"groups": {
    "build": {
        "options": {
            "env":   ["NODE_ENV=build"],
            "mount": [".:/path/to/src"]
        },
        "containers": {
            "nfprocessor": {
                "port": ["4321:1234"]
            }
        }
    }

}
</code></pre>

<p>The above would create a new group called <code>build</code>, which when
used would apply the relevant options when creating a cluster of containers.
Per-container overrides can also be set, though these are optional. Opting
into a group simply requires a slightly different cluster definition:</p>

<pre><code>"clusters": {
  "main": ["nfprocessor", "nfconsumer"],
  "dev": {
      "group": "build",
      "containers": ["nfprocessor", "nfconsumer"]
  }
}
</code></pre>

<p>This would let us run two clusters based on the same containers, albeit one very clearly in
&lsquo;build&rsquo; mode. Of course we can&rsquo;t have two containers with different configurations sharing
the same <code>-name</code>, so decking namespaces containers based on the group name. In the above example,
a call to <code>decking create dev</code> would look for containers named <code>nfprocessor.build</code> and
<code>nfconsumer.build</code>. This namespacing is transparent to a user, meaning containers can always
be thought of and referred to (i.e. as dependencies) by their original name.</p>

<p>Note that for now, group-wide options completely overwrite any previous values for matching keys
rather than merge them with existing ones. Likewise, a container-level override overwrites
any previous values (even those set at group level). This will be changed in future such that
options are merged properly in a predictable manner.</p>

        </section>

        <aside id="sidebar">
          <a href="https://npmjs.org/package/decking" class="button">
            <small>Download via npm</small>
            0.0.12
          </a>

          <p class="repo-owner"><a href="https://github.com/makeusabrew/decking">decking</a> is maintained by <a href="https://github.com/makeusabrew">makeusabrew</a>.</p>

          <ul>
            <li><a href=#installation>Installation</a></li>
            <li><a href=#about>Why decking?</a></li>
            <li><a href=#format>decking.json format</a>
              <ul>
                <li><a href="#format-images">images</a></li>
                <li><a href="#format-containers">containers</a></li>
                <li><a href="#format-clusters">clusters</a></li>
                <li><a href="#format-groups">groups</a></li>
              </ul>
            </li>
          </ul>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-20517424-10");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
