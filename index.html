<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Create, manage and run clusters of Docker containers | decking.io</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>decking.io</h1>
        <h2>Create, manage and run clusters of Docker containers</h2>
        <a href="https://github.com/makeusabrew/decking" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1> <span class="octicon octicon-link"></span>Simplified management for clusters of Docker containers</h1>

<p>Decking aims to simplify the creation, management and running of clusters
of Docker containers in a way which is familiar to developers;
by reading information from a <code>decking.json</code> package file
on a project by project basis. You can view a
<a href="http://showterm.io/21bc0f5d5ddbe4a1c4f2a">showterm recording</a>
of decking in action or check out a simple
<a href="https://github.com/makeusabrew/nodeflakes/blob/master/decking.json">decking.json</a>
example file.</p>

<h2>
<a name="installation" class="anchor" href="#installation"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>Although under heavy development, the more recent releases on npm are stable:</p>

<pre class="reduced">$ [sudo] <b>npm install -g decking</b></pre>

<p>Alternatively, just clone the repo and run <code>./bin/decking</code>. You&rsquo;ll
need CoffeeScript installed globally in order for this to work.</p>

<p>Once installed decking can be run (without arguments) from anywhere:</p>
<pre>$ <b>decking</b>

Usage: decking COMMAND [arg...]

Commands:
  build    build an image or pass 'all' to build all
  create   create a cluster of containers
  start    start a cluster
  stop     stop a cluster
  restart  restart a cluster
  status   check the status of a cluster's containers
  attach   attach to all running containers in a cluster

Version: 0.0.12</pre>

<p>These commands only make sense with some context; that context must be provided
by a local <b>decking.json</b> file.</p>

<h2>
<a name="about" class="anchor" href="#about"><span class="octicon octicon-link"></span></a>Why?</h2>

<p>Decking simplifies the <b>building of images</b> based on local Dockerfiles which can ordinarily be a time-consuming and error prone process (building the wrong Dockerfile as the wrong image, and having to move the Dockerfile to the root of a project in order to make the <code>ADD</code> directive work properly).</p>

<p>It simplifies the <b>creation of containers</b> by considering <code>docker run</code> parameters to be part of the definition of each
container - again meaning less room for error as each developer doesn't have to remember the correct run time parameters to use when creating each container.</p>

<p>It simplifies the <b>running of containers</b> by allowing dependencies to be specified, ensuring that all containers forming
part of a cluster are started in the correct order such that <code>-link</code> parameters work as expected. Entire clusters of containers can be started, stopped or attached to with a single command, without having to worry about restarting them in dependency order.</p>

<!--<p>It intends to use the Docker Remote API wherever possible (not everywhere, does
not appear to support <code>-name</code> and <code>-link</code> flags yet).</p>-->


<h2>
<a name="deckingjson-format" class="anchor" href="#deckingjson-format"><span class="octicon octicon-link"></span></a>The decking.json file format</h2>

<p>The decking.json format aims to be clear, concise and simple. Note that the file
must be present in the current working directory; decking will not recurse up parent
directories looking for a valid definition file. The top-level keys are:</p>

<pre><code>"images":     { /* the images which power your containers */ },
"containers": { /* the container templates which make up your clusters */ },
"clusters":   { /* lists of containers which combine to form a cluster */ },
"groups":     { /* optional overrides for different environments */ }
</code></pre>

<h3>
<a name="images-object" class="anchor" href="#images-object"><span class="octicon octicon-link"></span></a>images</h3>

<p>Docker images define the templates from which containers are built; decking gives them
a boost by being able to build them in batches and resolving commonly encountered
&lsquo;context&rsquo; difficulties:</p>

<ul class="requirements">
  <li>required: <b>no</b></li>
  <li>type: <b>object</b></li>
</ul>

<p>Each key is the name of the image you want to build. Each value is the location of
the <em>local</em> Dockerfile relative to the project root. Only local images
can be built at the moment, although eventually you'll be able to specify tag names
as values in to build an image from the Docker Index instead.</p>

<pre><code>"images": {
  "makeusabrew/nodeflakes": "./docker/base",
  "makeusabrew/nodeflakes-server": "./docker/server",
  "makeusabrew/nodeflakes-consumer": "./docker/consumer",
  "makeusabrew/nodeflakes-processor": "./docker/processor"
}
</code></pre>

<p>When building an image the relevant Dockerfile will be copied to the root
of your project (i.e. to the same directory as your decking.json file) such
that any <code>ADD</code> directives will be relative to your project root.</p>

<h3>
<a name="containers" class="anchor" href="#containers"><span class="octicon octicon-link"></span></a>containers</h3>

<p>Containers define the runtime configuration for a given image. They let you
model instances&mdash;and crucially, their dependencies&mdash;in a clear, clean
and repeatable manner, meaning you don&rsquo;t have to remember all those arguments
when creating a new container.</p>

<ul class="requirements">
  <li>required: <b>yes</b></li>
  <li>type: <b>object</b></li>
</ul>

<p>Keys are the names you want to run your containers as (e.g.
<code>docker run -name &lt;key&gt; ...</code>). Values are either
a string&mdash;in which case they must refer to a valid <code>images</code>
key&mdash;or an object. A definition of two containers demonstrating
both approaches might look a bit like this:</p>

<pre><code>"containers": {
  "nfprocessor": {
    "image": "makeusabrew/nodeflakes-processor",
    "port" : ["1234:1234"],
    "env": : ["MY_ENV_VAR=value", "ANOTHER_VAR=-"]
    "dependencies": [
      "nfconsumer:consumer"
    ],
    "mount": ["/path/to/host-dir:/path/to/container-dir"]
  },
  "nfconsumer": "makeusabrew/nodeflakes-consumer"
}
</code></pre>

<p>Each key in the definition of <code>nfprocessor</code> maps loosely onto an argument which will be passed to <code>docker run</code>:</p>

<pre class="reduced">port         &rarr; <b>-p</b>
env          &rarr; <b>-e</b>
dependencies &rarr; <b>-link</b>
mount        &rarr; <b>-v</b>
image        &ndash; supplied as-is as the last part of the run command</pre>

<!--<p>It might be simpler to remove this abstraction and just name these keys exactly as per the arguments passed to docker run, but you'd end up with some pretty ugly looking definitions full of single letter keys. Nevertheless, this <em>may</em> change.</p>-->

<p>Notice that our env var <code>ANOTHER_VAR</code> is defined simply as
<code>-</code>. This is a special value which, when the container is first created,
will be substituted with the current value of
<code>process.env['ANOTHER_VAR']</code>. If that yields a falsy value the user
will be prompted for it. You will only be prompted for any missing environment
variables when calling <code>decking create &lt;cluster&gt;</code>. Of course,
if you manually <code>docker rm</code> a container used in the cluster and then
call <code>decking create &lt;cluster&gt;</code> again you will be prompted for
the value once more.</p>

<h3>
<a name="clusters" class="anchor" href="#clusters"><span class="octicon octicon-link"></span></a>clusters</h3>

<p>Clusters define sets of related containers which&mdash;presumably&mdash;combine
in some useful way (e.g. a master &amp; slave database, a couple of web servers
and a load balancer). This is where it all happens!

<ul class="requirements">
  <li>required: <b>yes</b></li>
  <li>type: <b>object</b></li>
</ul>

<p>Keys are the names of clusters you want to refer to, values are usually
just arrays of keys found in the <code>containers</code> object. These
definitions are simple as most of the configuration has already been done
elsewhere:</p>

<pre><code>"clusters": {
  "main": ["nfprocessor", "nfconsumer"]
}
</code></pre>

<p>The order we list our containers as part of each cluster definition
doesn't matter - decking will resolve the dependencies based on each
container's definition and make sure they start in the correct order.</p>

<p>As we have only defined one cluster we can omit it when calling any
of the cluster related commands &ndash; e.g.
<code>decking start main</code> can be shortened to
<code>decking start</code>. If two or more cluster definitions are present
then a cluster name must always be provided.</p>

<h3>
<a name="groups-optional-object" class="anchor" href="#groups-optional-object"><span class="octicon octicon-link"></span></a>groups</h3>

<p>Groups allow clusters of containers to be run with different parameters, usually
to support small configuration variations across different environments (e.g.
build, test, production).</p>

<ul class="requirements">
  <li>required: <b>no</b></li>
  <li>type: <b>object</b></li>
</ul>

<p>Keys are the names of cluster definitions to override, values are
cluster-wide and container-specific overrides:</p>

<pre><code>"groups": {
    "build": {
        "options": {
            "env":   ["NODE_ENV=build"],
            "mount": [".:/path/to/src"]
        },
        "containers": {
            "nfprocessor": {
                "port": ["4321:1234"]
            }
        }
    }

}
</code></pre>

<p>The above would create a new group called <code>build</code>, which when
used would apply the relevant options when creating a cluster of containers.
Per-container overrides can also be set, though these are optional. Opting
into a group simply requires a slightly different cluster definition:</p>

<pre><code>"clusters": {
  "main": ["nfprocessor", "nfconsumer"],
  "dev": {
      "group": "build",
      "containers": ["nfprocessor", "nfconsumer"]
  }
}
</code></pre>

<p>This would let us run two clusters based on the same containers, albeit one very clearly in
&lsquo;build&rsquo; mode. Of course we can't have two containers with different configurations sharing
the same <code>-name</code>, so decking namespaces containers based on the group name. In the above example,
a call to <code>decking create dev</code> would look for containers named <code>nfprocessor.build</code> and
<code>nfconsumer.build</code>. This namespacing is transparent to a user, meaning containers can always
be thought of and referred to (i.e. as dependencies) by their original name.</p>

<p>Note that for now, group-wide options completely overwrite any previous values for matching keys
rather than merge them with existing ones. Likewise, a container-level override overwrites
any previous values (even those set at group level). This will be changed in future such that
options are merged properly in a predictable manner.</p>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/makeusabrew/decking/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/makeusabrew/decking/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/makeusabrew/decking">decking</a> is maintained by <a href="https://github.com/makeusabrew">makeusabrew</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-20517424-10");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
